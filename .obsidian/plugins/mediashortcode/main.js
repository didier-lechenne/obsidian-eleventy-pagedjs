/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImageCaptions
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_MEDIA_TYPES = {
  image: {
    name: "Image",
    template: '<figure data-type="{type}" data-grid="image" class="figure {type} {classes}" id="{id}" data-src="{src}">{media}<figcaption class="figcaption">{caption}</figcaption></figure>',
    extensions: []
  },
  imagenote: {
    name: "Image Note",
    template: '<span data-type="{type}" class="{type} {classes}" id="{id}" data-src="{src}">{media}<span class="figcaption">{caption}</span></span>',
    extensions: []
  },
  figure: {
    name: "Figure",
    template: '<figure data-type="{type}" data-grid="image" class="{type} {classes}">{media}<figcaption class="figcaption">{caption}</figcaption></figure>',
    extensions: []
  },
  grid: {
    name: "Grid",
    template: '<figure data-type="{type}" data-grid="image" class="figure {type} {classes}">{media}</figure><figcaption class="figcaption">{caption}</figcaption>',
    extensions: []
  },
  fullpage: {
    name: "Full Page",
    template: '<figure data-type="{type}" data-grid="image" class="full-page figure {type} {classes}">{media} <figcaption class="figcaption">{caption}</figcaption> </figure>',
    extensions: []
  }
};
var DEFAULT_SETTINGS = {
  captionRegex: "",
  mediaTypes: DEFAULT_MEDIA_TYPES
};
var CaptionSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Media Shortcode Settings").setHeading();
    new import_obsidian.Setting(containerEl).setName("Caption regex").setDesc("For advanced caption parsing, you can add a regex here. The first capturing group will be used as the image caption.").addText((text) => text.setPlaceholder("^([^|]+)").setValue(this.plugin.settings.captionRegex).onChange(async (value) => {
      this.plugin.settings.captionRegex = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Media Types & Templates").setHeading();
    Object.entries(this.plugin.settings.mediaTypes).forEach(([type, config]) => {
      new import_obsidian.Setting(containerEl).setName(`${config.name} Template`).setDesc(`HTML template for ${type}. Available variables: {type}, {classes}, {id}, {src}, {media}, {caption}`).addTextArea((text) => {
        text.setValue(config.template);
        text.inputEl.style.height = "100px";
        text.inputEl.style.fontFamily = "monospace";
        text.onChange(async (value) => {
          this.plugin.settings.mediaTypes[type].template = value;
          await this.plugin.saveSettings();
        });
      });
      new import_obsidian.Setting(containerEl).setName(`${config.name} Extensions`).setDesc(`File extensions for auto-detection (comma separated)`).addText((text) => text.setValue(config.extensions.join(", ")).onChange(async (value) => {
        this.plugin.settings.mediaTypes[type].extensions = value.split(",").map((ext) => ext.trim()).filter((ext) => ext.length > 0);
        await this.plugin.saveSettings();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Reset Templates").setDesc("Reset all templates to default values").addButton((button) => button.setButtonText("Reset to Defaults").onClick(async () => {
      this.plugin.settings.mediaTypes = { ...DEFAULT_MEDIA_TYPES };
      await this.plugin.saveSettings();
      this.display();
    }));
  }
};

// src/main.ts
var TypeDetector = class {
  constructor(mediaTypes) {
    this.mediaTypes = mediaTypes;
  }
  detectFromFilename(filename) {
    const ext = this.getFileExtension(filename);
    for (const [typeName, config] of Object.entries(this.mediaTypes)) {
      if (!["image", "imagenote", "figure", "grid"].includes(typeName)) continue;
      if (config.extensions.includes(ext)) {
        return typeName;
      }
    }
    return "figure";
  }
  detectFromKeyword(params) {
    const allowedTypes = ["image", "imagenote", "figure", "grid", "fullpage"];
    for (const param of params) {
      const lowerParam = param.toLowerCase();
      if (allowedTypes.includes(lowerParam)) {
        return lowerParam;
      }
    }
    return null;
  }
  getFileExtension(filename) {
    const lastDot = filename.lastIndexOf(".");
    return lastDot === -1 ? "" : filename.substring(lastDot).toLowerCase();
  }
};
var MediaParser = class {
  constructor(typeDetector) {
    this.typeDetector = typeDetector;
  }
  parseAttributes(altText, filename) {
    const result = {
      type: "figure",
      // default type is 'figure'
      caption: "",
      classes: []
    };
    if (!altText) {
      if (filename) {
        result.type = this.typeDetector.detectFromFilename(filename);
      }
      return result;
    }
    const cleanedAltText = altText.replace(/\s+/g, " ").trim();
    const parts = cleanedAltText.split("|").map((part) => part.trim());
    const keywordType = this.typeDetector.detectFromKeyword(parts);
    if (keywordType) {
      result.type = keywordType;
      const keywordIndex = parts.findIndex((p) => p.toLowerCase() === keywordType);
      if (keywordIndex !== -1) {
        parts.splice(keywordIndex, 1);
      }
    } else if (filename) {
      result.type = this.typeDetector.detectFromFilename(filename);
    }
    for (const part of parts) {
      if (part.includes(":")) {
        this.parseKeyValuePair(part, result);
      } else if (part && !result.caption) {
        result.caption = part;
      }
    }
    return result;
  }
  parseKeyValuePair(part, result) {
    const [key, ...valueParts] = part.split(":");
    const value = valueParts.join(":").trim();
    switch (key.toLowerCase()) {
      case "caption":
        result.caption = value;
        break;
      case "class":
        result.classes = value.split(",").map((cls) => cls.trim());
        break;
      case "width":
        result.width = value;
        break;
      case "col":
        result.col = value;
        break;
      case "fullpage":
      case "full-page":
        result["pagedjs-full-page"] = value;
        break;
      case "alignself":
      case "align-self":
        result["align-self"] = value;
        break;
      case "print-col":
      case "printcol":
        result["print-col"] = value;
        break;
      case "print-width":
      case "printwidth":
        result["print-width"] = value;
        break;
      case "print-row":
      case "printrow":
        result["print-row"] = value;
        break;
      case "print-height":
      case "printheight":
        result["print-height"] = value;
        break;
      case "print-x":
      case "img-x":
      case "imgx":
        result["print-x"] = value;
        break;
      case "print-y":
      case "img-y":
      case "imgy":
        result["print-y"] = value;
        break;
      case "img-w":
      case "imgw":
        result["img-w"] = value;
        break;
      default:
        result[key.toLowerCase()] = value;
        break;
    }
  }
};
var TemplateEngine = class {
  render(template, data) {
    return template.replace(/{type}/g, data.type).replace(/{classes}/g, data.classes).replace(/{id}/g, data.id).replace(/{src}/g, data.src).replace(/{media}/g, data.media).replace(/{caption}/g, data.caption);
  }
};
var MediaRenderer = class {
  constructor(templateEngine, mediaTypes, plugin) {
    this.templateEngine = templateEngine;
    this.mediaTypes = mediaTypes;
    this.plugin = plugin;
  }
  async renderMedia(mediaEl, container, parsedData, sourcePath) {
    if (mediaEl.tagName !== "IMG") {
      return;
    }
    if (!["image", "imagenote", "figure", "grid", "fullpage"].includes(parsedData.type)) {
      return;
    }
    const mediaType = this.mediaTypes[parsedData.type] || this.mediaTypes.figure;
    const templateData = {
      type: parsedData.type,
      classes: parsedData.classes.join(" "),
      id: this.generateId(mediaEl),
      src: mediaEl.getAttribute("src") || "",
      media: "",
      // Sera remplacé par l'élément réel
      caption: parsedData.caption
    };
    const htmlString = this.templateEngine.render(mediaType.template, templateData);
    const tempDiv = createDiv();
    tempDiv.innerHTML = htmlString;
    const newContainer = tempDiv.firstElementChild;
    if (newContainer) {
      if (parsedData.type === "grid") {
        const allElements = Array.from(tempDiv.children);
        const figureEl = tempDiv.querySelector("figure");
        const captionEl = tempDiv.querySelector("figcaption");
        if (figureEl) {
          if (parsedData.caption) {
            mediaEl.setAttribute("alt", parsedData.caption);
          }
          figureEl.appendChild(mediaEl);
          this.applyStyles(figureEl, parsedData);
        }
        if (parsedData.caption && captionEl) {
          const children = await this.renderMarkdown(parsedData.caption, sourcePath);
          this.updateCaption(captionEl, children);
          this.applyStyles(captionEl, parsedData);
        }
        allElements.forEach((el) => container.appendChild(el));
        return;
      } else {
        newContainer.innerHTML = "";
        if (parsedData.caption) {
          mediaEl.setAttribute("alt", parsedData.caption);
        }
        newContainer.appendChild(mediaEl);
        if (parsedData.caption) {
          let captionEl;
          if (parsedData.type === "imagenote") {
            captionEl = newContainer.createEl("span", { cls: "figcaption" });
          } else {
            captionEl = newContainer.createEl("figcaption", { cls: "figcaption" });
          }
          const children = await this.renderMarkdown(parsedData.caption, sourcePath);
          this.updateCaption(captionEl, children);
        }
      }
      if (parsedData.type !== "grid") {
        this.applyStyles(newContainer, parsedData);
      }
      if (parsedData.type !== "grid") {
        container.appendChild(newContainer);
      }
    }
  }
  generateId(mediaEl) {
    var _a, _b;
    const src = mediaEl.getAttribute("src") || "";
    const filename = ((_b = (_a = src.split("/").pop()) == null ? void 0 : _a.replace(/\?.*$/, "")) == null ? void 0 : _b.replace(/\./g, "")) || "";
    return `content${filename}`;
  }
  applyStyles(container, parsedData) {
    const styles = [];
    const excludedProps = ["type", "caption", "classes"];
    Object.entries(parsedData).forEach(([key, value]) => {
      if (typeof value === "string" && !excludedProps.includes(key)) {
        styles.push(`--${key}: ${value}`);
      }
    });
    if (styles.length > 0) {
      container.setAttribute("style", styles.join("; "));
    }
  }
  async renderMarkdown(markdown, sourcePath) {
    const el = createDiv();
    await import_obsidian2.MarkdownRenderer.renderMarkdown(markdown, el, sourcePath, this.plugin);
    const nodes = [];
    for (const child of el.childNodes) {
      nodes.push(child);
    }
    return nodes.length > 0 ? nodes : [document.createTextNode(markdown)];
  }
  updateCaption(captionEl, children) {
    if (children.length === 1 && children[0] instanceof HTMLParagraphElement) {
      const pElement = children[0];
      captionEl.replaceChildren(...Array.from(pElement.childNodes));
    } else {
      captionEl.replaceChildren(...children);
    }
  }
};
var ImageCaptions = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.figureGridProcessor = (source, el, ctx) => {
      const container = el.createDiv({ cls: "columnGrid" });
      const wikilinks = this.extractWikilinks(source);
      Promise.all(wikilinks.map(
        (wikilink) => this.processGridImage(wikilink, container, ctx.sourcePath)
      ));
    };
  }
  async onload() {
    await this.loadSettings();
    this.typeDetector = new TypeDetector(this.settings.mediaTypes);
    this.mediaParser = new MediaParser(this.typeDetector);
    this.templateEngine = new TemplateEngine();
    this.mediaRenderer = new MediaRenderer(this.templateEngine, this.settings.mediaTypes, this);
    this.addSettingTab(new CaptionSettingTab(this.app, this));
    this.registerMarkdownCodeBlockProcessor("columnGrid", this.figureGridProcessor.bind(this));
    this.registerMarkdownPostProcessor(this.mediaProcessor());
    this.setupMutationObserver();
    this.addEditOnClickToGrids();
  }
  setupMutationObserver() {
    this.observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "childList") {
          this.processChildListChanges(mutation);
        } else if (mutation.type === "attributes") {
          this.processAttributeChanges(mutation);
        }
      });
    });
    this.observer.observe(document.body, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["alt", "src", "data-path"]
    });
  }
  processChildListChanges(mutation) {
    setTimeout(() => {
      mutation.target.querySelectorAll(".image-embed, .internal-embed").forEach(async (embedContainer) => {
        await this.processEmbedContainer(embedContainer);
      });
    }, 100);
  }
  processAttributeChanges(mutation) {
    const target = mutation.target;
    if (target.classList.contains("internal-embed") && mutation.attributeName === "alt") {
      setTimeout(() => this.processEmbedContainer(target, true), 100);
    }
    if (target.tagName === "IMG" && (mutation.attributeName === "alt" || mutation.attributeName === "src")) {
      setTimeout(() => this.updateExistingMedia(target), 10);
    }
  }
  async processEmbedContainer(embedContainer, force = false) {
    const mediaEl = embedContainer.querySelector("img");
    if (!mediaEl) return;
    if (!force && this.isAlreadyProcessed(mediaEl)) return;
    if (embedContainer.hasAttribute("data-processing")) return;
    embedContainer.setAttribute("data-processing", "true");
    if (force) {
      const existingElements = embedContainer.querySelectorAll("figure, span.imagenote, .grid");
      existingElements.forEach((el) => el.remove());
    }
    const altText = embedContainer.getAttribute("alt") || "";
    const src = mediaEl.getAttribute("src") || "";
    const filename = src.split("/").pop() || "";
    const parsedData = this.mediaParser.parseAttributes(altText, filename);
    if (this.shouldProcessMedia(parsedData)) {
      await this.mediaRenderer.renderMedia(mediaEl, embedContainer, parsedData, "");
    }
    embedContainer.removeAttribute("data-processing");
  }
  async updateExistingMedia(target) {
    if (target.tagName !== "IMG") return;
    const container = target.closest("figure, span[class*='imagenote'], .grid");
    if (!container) return;
    const altText = target.getAttribute("alt") || "";
    const src = target.getAttribute("src") || "";
    const filename = src.split("/").pop() || "";
    const parsedData = this.mediaParser.parseAttributes(altText, filename);
    const captionEl = container.querySelector(".figcaption, figcaption");
    if (captionEl && parsedData.caption) {
      const children = await this.mediaRenderer["renderMarkdown"](parsedData.caption, "");
      this.mediaRenderer["updateCaption"](captionEl, children);
    }
  }
  shouldProcessMedia(parsedData) {
    if (!["image", "imagenote", "figure", "grid", "fullpage"].includes(parsedData.type)) return false;
    return !!(parsedData.caption || parsedData.col || parsedData.width || parsedData["print-col"] || parsedData["print-width"] || parsedData["print-row"] || parsedData["print-height"] || parsedData["print-x"] || parsedData["print-y"] || parsedData["img-w"] || parsedData["align-self"] || parsedData["pagedjs-full-page"] || parsedData.type !== "figure");
  }
  extractWikilinks(source) {
    const wikilinks = [];
    const regex = /!\[\[\s*([^|\]]+?)\s*(?:\|([\s\S]*?))?\]\]/g;
    let match;
    while ((match = regex.exec(source)) !== null) {
      wikilinks.push(match[0]);
    }
    return wikilinks;
  }
  async processGridImage(imageSyntax, container, sourcePath) {
    const match = imageSyntax.match(/!\[\[\s*([^|\]]+?)\s*(?:\|([\s\S]+?))?\]\]/);
    if (!match) return;
    const imagePath = match[1].trim();
    const params = match[2] ? match[2].trim() : "";
    const abstractFile = this.app.metadataCache.getFirstLinkpathDest(imagePath, sourcePath);
    if (!abstractFile) {
      console.warn(`File not found: ${imagePath}`);
      return;
    }
    const resolvedPath = this.app.vault.getResourcePath(abstractFile);
    const parsedData = this.mediaParser.parseAttributes(params, imagePath);
    const mediaEl = container.createEl("img");
    mediaEl.setAttribute("src", resolvedPath);
    if (parsedData.caption) {
      mediaEl.setAttribute("alt", parsedData.caption);
    }
    await this.mediaRenderer.renderMedia(mediaEl, container, parsedData, sourcePath);
  }
  mediaProcessor() {
    return (el, ctx) => {
      el.findAll("img:not(.emoji)").forEach(async (mediaEl) => {
        const altText = mediaEl.getAttribute("alt") || "";
        const src = mediaEl.getAttribute("src") || "";
        const filename = src.split("/").pop() || "";
        const parsedData = this.mediaParser.parseAttributes(altText, filename);
        const parent = mediaEl.parentElement;
        if (parent && !this.isAlreadyProcessed(mediaEl) && this.shouldProcessMedia(parsedData)) {
          await this.mediaRenderer.renderMedia(mediaEl, parent, parsedData, ctx.sourcePath);
        }
      });
      setTimeout(() => {
        el.findAll(".internal-embed").forEach((embedContainer) => {
          this.processEmbedContainer(embedContainer);
        });
      }, 100);
    };
  }
  isAlreadyProcessed(mediaEl) {
    var _a;
    const container = mediaEl.closest("figure, span[class*='imagenote']");
    if (container && (container.classList.contains("grid") || container.classList.contains("figure") || container.classList.contains("imagenote"))) {
      return true;
    }
    return !!((_a = mediaEl.parentElement) == null ? void 0 : _a.querySelector(".figcaption, figcaption"));
  }
  addEditOnClickToGrids() {
    document.addEventListener("click", (event) => {
      const target = event.target;
      const gridContainer = target.closest(".columnGrid");
      if (gridContainer) {
        const editButton = this.findEditButton(gridContainer);
        if (editButton) {
          editButton.click();
          event.preventDefault();
          event.stopPropagation();
        }
      }
    });
  }
  findEditButton(container) {
    let parent = container.parentElement;
    while (parent) {
      const editButton = parent.querySelector(".edit-block-button");
      if (editButton) return editButton;
      parent = parent.parentElement;
    }
    return null;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.typeDetector = new TypeDetector(this.settings.mediaTypes);
    this.mediaParser = new MediaParser(this.typeDetector);
    this.mediaRenderer = new MediaRenderer(this.templateEngine, this.settings.mediaTypes, this);
  }
  onunload() {
    var _a;
    (_a = this.observer) == null ? void 0 : _a.disconnect();
  }
};
